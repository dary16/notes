###App登录认证方式
由于App客户端无法处理Cookie信息，因此App登录认证无法使用Web认证方式中的Cookie认证方式，为了登录状态的保持，一般会模拟Cookie认证方式，即在App端发起登录认证请求后，得到服务端验证成功的确认之后，App端一般会保存一些状态信息在本地，后面每次请求都是携带该状态信息，根据状态信息的不同，可以分为如下两种：

   (1) 保存用户信息表中的某个唯一标识。App端发起登录请求，服务器端在验证成功之后一般会将该登录用户的信息返回给客户端，客户端此时可以将用户信息中的某个唯一标识字段给保存下来，如使用SharedPreference进行保存，后面每次发起网络请求时，先判断本地是否存在该字段，如果不存在说明用户没有进行登录认证，跳转到登录页；如果存在，则直接将这个字段携带进请求信息中，从而实现登录保持状态。这种方式优点是比较简单，缺点就是如果保存的字段容易被别人截获，缺乏安全性。

    (2)保存Token信息。App中非常常用的一种登录认证方式，他的实现过程是，由App端发起登录请求，服务器端在验证成功后生成一份Token信息保存到用户表中并设置一定的时效，同时将此Token返回给App端，App端将此Token保存到本地，以后的每次发起请求都是用该Token。与前面一种方式相比，避免了用户表中信息的泄露，相对更加安全。其流程图如下
2.1 登录验证优化

      登录验证阶段是指App客户端向服务器端发起登录认证请求，并携带用户名和密码，服务器端收到请求后获取用户名和密码，并向数据库进行查询验证的阶段。由于这一阶段需要密码的传输，很多情况下可能都是明文或者简单的MD5加密后直接传输，一旦被黑客截获可能造成密码的泄露风险。因此这一阶段的优化就是加强密码加密功能，这里我们采用RSA非对称加密方式。

     RSA是一种非对称加密，它是对称加密的一种加强版，使用对称加密的服务器端和客户端都使用同一种加密规则，因此在服务器端生成加密密钥之后需要传递给客户端，客户端也需要保存这个密钥，而传递密钥的过程和保存密钥在客户端后都有可能发生密钥的截获造成安全漏洞。而非对称加密方式会在服务器端生成两套密钥，生成的公钥是公开的并传给客户端，私钥保存在服务器端，客户端用公钥加密信息后传递到服务器端，服务器端再用私钥进行解密，因此只要私钥不泄露，通信就是安全的。


### app与后台的token、sessionId、RSA加密登录认证与安全解决方案
1.登录机制
粗略地分析， 登录机制主要分为登录验证、登录保持、登出三个部分。登录验证是指客户端提供用户名和密码，向服务器提出登录请求，服务器判断客户端是否可以登录并向客户端确认。 登录认保持是指客户端登录后， 服务器能够分辨出已登录的客户端，并为其持续提供登录权限的服务器。登出是指客户端主动退出登录状态。容易想到的方案是，客户端登录成功后， 服务器为其分配sessionId, 客户端随后每次请求资源时都带上sessionId
1.1.1 密码的传输
客户端第一次发出登录请求时， 用户密码以明文的方式传输， 一旦被截获， 后果严重。因此密码需要加密，例如可采用RSA非对称加密。具体流程如下：

客户端向服务器第一次发起登录请求（不传输用户名和密码）。
服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。
客户端收到公钥后， 加密用户密码， 向服务器发起第二次登录请求（传输用户名和加密后的密码）。
服务器利用保留的私钥对密文进行解密，得到真正的密码。

1.1.2 登录状态token
再仔细核对上述登录流程， 我们发现服务器判断用户是否登录， 完全依赖于sessionId, 一旦其被截获， 黑客就能够模拟出用户的请求。于是我们需要引入token的概念： 用户登录成功后， 服务器不但为其分配了sessionId, 还分配了token， token是维持登录状态的关键秘密数据。在服务器向客户端发送的token数据，也需要加密。于是一次登录的细节再次扩展。

客户端向服务器第一次发起登录请求（不传输用户名和密码）。
服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。
客户端收到公钥后， 加密用户密码，向服务器发送用户名和加密后的用户密码； 同时另外产生一对公钥和私钥，自己保留私钥, 向服务器发送公钥； 于是第二次登录请求传输了用户名和加密后的密码以及客户端生成的公钥。
服务器利用保留的私钥对密文进行解密，得到真正的密码。 经过判断， 确定用户可以登录后，生成sessionId和token， 同时利用客户端发送的公钥，对token进行加密。最后将sessionId和加密后的token返还给客户端。
客户端利用自己生成的私钥对token密文解密， 得到真正的token

2.登录保持
在最原始的方案中， 登录保持仅仅靠服务器生成的sessionId: 客户端的请求中带上sessionId, 如果服务器的redis中存在这个id，就认为请求来自相应的登录客户端。 但是只要sessionId被截获， 请求就可以为伪造， 存在安全隐患。
引入token后，上述问题便可得到解决。 服务器将token和其它的一些变量， 利用散列加密算法得到签名后，连同sessionId一并发送给服务器； 服务器取出保存于服务器端的token,利用相同的法则生成校验签名， 如果客户端签名与服务器的校验签名一致， 就认为请求来自登录的客户端

